import os, sys, shutil
import time
import pickle
import numpy as np
import random
from scipy import misc
import six
from six.moves import urllib, range
import copy
import logging
import cv2
import json
import uuid

from data import VOCroot, COCOroot, VOC_300, VOC_512, COCO_300, COCO_512, COCO_mobile_300, AnnotationTransform, \
    COCODetection, VOCDetection, detection_collate, BaseTransform, preproc

try:
    from .cfgs.config import cfg
    from .utils_bak import Box, box_iou, encode_box
except Exception:
    from cfgs.config import cfg
    from utils_bak import Box, box_iou, encode_box

from tensorpack import *

SAVE_DIR = 'input_images'

def intersect(box_a, box_b):
    max_xy = np.minimum(box_a[:, 2:], box_b[2:])
    min_xy = np.maximum(box_a[:, :2], box_b[:2])
    inter = np.clip((max_xy - min_xy), a_min=0, a_max=np.inf)
    return inter[:, 0] * inter[:, 1]


def jaccard_numpy(box_a, box_b):
    """Compute the jaccard overlap of two sets of boxes.  The jaccard overlap
    is simply the intersection over union of two boxes.
    E.g.:
        A ∩ B / A ∪ B = A ∩ B / (area(A) + area(B) - A ∩ B)
    Args:
        box_a: Multiple bounding boxes, Shape: [num_boxes,4]
        box_b: Single bounding box, Shape: [4]
    Return:
        jaccard overlap: Shape: [box_a.shape[0], box_a.shape[1]]
    """
    inter = intersect(box_a, box_b)
    area_a = ((box_a[:, 2]-box_a[:, 0]) *
              (box_a[:, 3]-box_a[:, 1]))  # [A,B]
    area_b = ((box_b[2]-box_b[0]) *
              (box_b[3]-box_b[1]))  # [A,B]
    union = area_a + area_b - inter
    return inter / union

rgb_std = (1, 1, 1)
img_dim = (300, 512)[0]
# rgb_means = (104, 117, 123)
rgb_means = (0, 0, 0)
p = (0.6, 0.2)[0]


class Data(RNGDataFlow):
    def __init__(self, filename_list, shuffle, flip, random_crop, random_expand, random_inter, save_img=False):
        self.filename_list = filename_list
        self.save_img = save_img

        if save_img == True:
            if os.path.isdir(SAVE_DIR):
                shutil.rmtree(SAVE_DIR)
            os.mkdir(SAVE_DIR)
            self.colors = [(255,0,0), (0,255,0), (0,0,255),
                           (255,255,0), (255,0,255), (0,255,255),
                           (122,0,0), (0,122,0), (0,0,122),
                           (122,122,0), (122,0,122), (0,122,122)]

        if isinstance(filename_list, list) == False:
            filename_list = [filename_list]

        content = []
        for filename in filename_list:
            with open(filename) as f:
                content.extend(f.readlines())

        self.imglist = [x.strip() for x in content] 
        self.shuffle = shuffle
        self.flip = flip
        self.random_crop = random_crop
        self.random_expand = random_expand
        self.random_inter = random_inter

        train_sets = [('2007', 'trainval'), ('2012', 'trainval')]
        self.train_dataset = VOCDetection(VOCroot, train_sets, preproc(
            img_dim, rgb_means, rgb_std, p), AnnotationTransform())

    def size(self):
        return len(self.imglist)

    def generate_sample(self, idx, image_height, image_width):

        image, target = self.train_dataset.__getitem__(idx)

        image = np.transpose(image.numpy(), (1, 2, 0))
        boxes = target[:,0:4] * 300
        class_ary = target[:,-1] - 1
        box_num = class_ary.shape[0]
        w = 300
        h = 300

        # only three variables are used in the following code:
        # image: 300 x 300 x 3 numpy array
        # boxes: N x 4 numpy array, N is boxes number, coordinates for each box
        # class_ary: N numpy array, N is boxes number, class for each box
        # these variables can be generated by the pytorch version dataset, and the data part can be switched to pytorch version

        anchor_iou = np.zeros((cfg.tot_anchor_num, ))
        # the backgound class is the 0th class
        anchor_cls = np.zeros((cfg.tot_anchor_num, )).astype(int)
        anchor_loc = np.zeros((cfg.tot_anchor_num, 4))

        gt_box_num = 0
        gt_box_coord = np.zeros((cfg.max_gt_box_shown, 4))
        for box_idx in range(box_num):
            if class_ary.shape[0] < box_num:
                import pdb
                pdb.set_trace()
            class_num = class_ary[box_idx]

            xmin, xmax = boxes[box_idx, 0::2] / w
            ymin, ymax = boxes[box_idx, 1::2] / h

            if gt_box_num < cfg.max_gt_box_shown:
                gt_box_coord[gt_box_num] = np.asarray([ymin, xmin, ymax, xmax])
                gt_box_num += 1

            gt_box = Box(xmin, ymin, xmax, ymax, mode='XYXY')

            gt_box_a = gt_box.w * gt_box.h


            # ugly, should be replaced with jaccard_numpy
            for anchor_idx, anchor in enumerate(cfg.all_anchors):
                if gt_box_a > anchor[4] or gt_box_a < anchor[5]:
                    continue
                if np.abs(gt_box.x - anchor[0]) > min(gt_box.w, anchor[2]) / 2:
                    continue
                if np.abs(gt_box.y - anchor[1]) > min(gt_box.h, anchor[3]) / 2:
                    continue
                anchor_box = Box(*anchor[:4])
                iou = box_iou(gt_box, anchor_box)
                if iou >= cfg.iou_th and iou > anchor_iou[anchor_idx]:
                    # the 0th class is the background, thus other classes' number should be pushed back 1
                    anchor_cls[anchor_idx] = class_num + 1
                    anchor_loc[anchor_idx] = encode_box(gt_box, anchor_box)
                if iou > anchor_iou[anchor_idx]:
                    anchor_iou[anchor_idx] = iou

        anchor_neg_mask = anchor_iou < cfg.neg_iou_th

        return [image, gt_box_coord, anchor_cls, anchor_neg_mask, anchor_loc, np.asarray([300,300, 3])]

    def get_data(self):
        idxs = np.arange(len(self.imglist))
        if self.shuffle:
            self.rng.shuffle(idxs)
        image_height = cfg.img_h
        image_width = cfg.img_w
        for k in idxs:
            retval = self.generate_sample(k, image_height, image_width)
            if retval == None:
                continue
            yield retval

    def get_data_idx(self):
        idxs = np.arange(len(self.imglist))
        if self.shuffle:
            self.rng.shuffle(idxs)
        for k in idxs:
            yield k

    def reset_state(self):
        super(Data, self).reset_state()

def generate_gt_result(test_path, gt_dir="result_gt", overwrite=True):
    if overwrite == False and os.path.isdir(gt_dir):
        return
    # generate the ground truth files for calculation of average precision
    if overwrite == True and os.path.isdir(gt_dir):
        shutil.rmtree(gt_dir)
    os.mkdir(gt_dir)


    with open(test_path) as f:
        content = f.readlines()

    gt_all = {}

    for line in content:
        record = line.split(' ')
        image_id = os.path.basename(record[0]).split('.')[0] if cfg.gt_format == "voc" else record[0]
        i = 1
        
        gt_cur_img = {}
        while i < len(record):
            class_num = int(record[i + 4])
            class_name = cfg.classes_name[class_num]
            
            if class_name not in gt_cur_img.keys():
                gt_cur_img[class_name] = []
            gt_cur_img[class_name].extend(record[i:i+4])
            
            i += 5
        
        for class_name, boxes in gt_cur_img.items():
            if class_name not in gt_all:
                gt_all[class_name] = []
            d = [image_id]
            d.extend(boxes)
            gt_all[class_name].append(d)
            

    for class_name in cfg.classes_name:
        if class_name in gt_all.keys():
            with open(os.path.join(gt_dir, class_name + ".txt"), 'w') as f:
                for line in gt_all[class_name]:
                    line = [str(ele) for ele in line]
                    f.write(' '.join(line) + '\n')

if __name__ == '__main__':
    # df = Data('voc_2007_train.txt', shuffle=False, flip=False, affine_trans=False)
    train_list = ["voc_2007_train.txt", "voc_2012_train.txt", "voc_2007_val.txt", "voc_2012_val.txt"]
    df = Data(train_list, shuffle=True, flip=True, random_crop=True, random_expand=True, random_inter=True, save_img=True)
    df.reset_state()

    g = df.get_data()
    for i in range(256):
        next(g)

    # for idx in range(100):
    #     if idx % 10 == 0:
    #         print(time.time())
    #     g = df.get_data()
    #     pb = next(g)
